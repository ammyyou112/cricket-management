generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                  String               @id @default(uuid())
  email               String               @unique
  password            String
  fullName            String               @map("full_name")
  role                UserRole             @default(PLAYER)
  playerType          PlayerType?          @map("player_type")
  phone               String?
  profilePictureUrl   String?              @map("profile_picture_url")
  city                String?
  locationLatitude    Decimal?             @map("location_latitude") @db.Decimal(10, 8)
  locationLongitude   Decimal?             @map("location_longitude") @db.Decimal(11, 8)
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  isBlocked           Boolean              @default(false) @map("is_blocked")
  isSuspended         Boolean              @default(false) @map("is_suspended")
  suspendReason       String?              @map("suspend_reason")
  suspendedAt         DateTime?            @map("suspended_at")
  matchesAsApprover   Match[]                    @relation("MatchApprover")
  matchesAsScorer     Match[]                    @relation("MatchScorer")
  notifications       Notification[]
  passwordResetTokens PasswordResetToken[]
  playerStats         PlayerStat[]
  refreshTokens       RefreshToken[]
  scoreUpdates        ScoreUpdate[]
  teamMemberships     TeamMember[]
  captainedTeams      Team[]                     @relation("TeamCaptain")
  createdTournaments  Tournament[]
  scoresSubmitted    MatchScoreVerification[]    @relation("ScoreSubmitter")
  scoresVerified      MatchScoreVerification[]    @relation("ScoreVerifier")
  approvalRequests    MatchStartApproval[]        @relation("ApprovalRequester")
  approvalsGiven     MatchStartApproval[]         @relation("ApprovalApprover")

  @@index([email])
  @@index([role])
  @@index([createdAt])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@index([used])
  @@map("password_reset_tokens")
}

model Team {
  id                String        @id @default(uuid())
  teamName          String        @unique @map("team_name")
  captainId         String        @map("captain_id")
  logoUrl           String?       @map("logo_url")
  description       String?
  city              String?
  locationLatitude  Decimal?      @map("location_latitude") @db.Decimal(10, 8)
  locationLongitude Decimal?      @map("location_longitude") @db.Decimal(11, 8)
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  matchScores       MatchScore[]
  matchesAsTeamA    Match[]       @relation("MatchTeamA")
  matchesAsTeamB    Match[]       @relation("MatchTeamB")
  matchesAsWinner   Match[]       @relation("MatchWinner")
  playerStats       PlayerStat[]
  scoreUpdates      ScoreUpdate[]
  members           TeamMember[]
  captain           User          @relation("TeamCaptain", fields: [captainId], references: [id], onDelete: Cascade)

  @@index([captainId])
  @@index([teamName])
  @@index([createdAt])
  @@map("teams")
}

model TeamMember {
  id          String           @id @default(uuid())
  teamId      String           @map("team_id")
  playerId    String           @map("player_id")
  status      TeamMemberStatus @default(PENDING)
  isTemporary Boolean          @default(false) @map("is_temporary")
  roleInTeam  String?          @map("role_in_team")
  joinedAt    DateTime?        @map("joined_at")
  createdAt   DateTime         @default(now()) @map("created_at")
  player      User             @relation(fields: [playerId], references: [id], onDelete: Cascade)
  team        Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, playerId])
  @@index([teamId])
  @@index([playerId])
  @@index([status])
  @@map("team_members")
}

model Tournament {
  id             String           @id @default(uuid())
  tournamentName String           @map("tournament_name")
  startDate      DateTime         @map("start_date") @db.Date
  endDate        DateTime         @map("end_date") @db.Date
  status         TournamentStatus @default(UPCOMING)
  createdBy      String           @map("created_by")
  description    String?
  location       String?
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")
  matches        Match[]
  creator        User             @relation(fields: [createdBy], references: [id])

  @@index([status])
  @@index([startDate, endDate])
  @@index([createdBy])
  @@map("tournaments")
}

model Match {
  id                  String                  @id @default(uuid())
  tournamentId        String?                  @map("tournament_id")
  teamAId             String                   @map("team_a_id")
  teamBId             String                   @map("team_b_id")
  venue               String
  matchDate           DateTime                 @map("match_date")
  matchType           MatchType?               @map("match_type")
  status              MatchStatus              @default(SCHEDULED)
  scoringCaptainId    String?                  @map("scoring_captain_id")
  approvedByCaptainId String?                  @map("approved_by_captain_id")
  winnerTeamId        String?                  @map("winner_team_id")
  createdAt           DateTime                 @default(now()) @map("created_at")
  updatedAt           DateTime                 @updatedAt @map("updated_at")
  // Scoring fields (Feature 4)
  scoringStatus       String?                  @default("NOT_STARTED") @map("scoring_status")
  currentInning       Int?                     @default(1) @map("current_inning")
  teamAScore          Int?                     @default(0) @map("team_a_score")
  teamAWickets        Int?                     @default(0) @map("team_a_wickets")
  teamAOvers          Decimal?                 @default(0) @map("team_a_overs") @db.Decimal(4, 1)
  teamBScore          Int?                     @default(0) @map("team_b_score")
  teamBWickets        Int?                     @default(0) @map("team_b_wickets")
  teamBOvers          Decimal?                 @default(0) @map("team_b_overs") @db.Decimal(4, 1)
  scoringStartedAt    DateTime?                @map("scoring_started_at")
  scoringCompletedAt  DateTime?                @map("scoring_completed_at")
  scoringStartedBy    String?                  @map("scoring_started_by")
  scores              MatchScore[]
  approvedByCaptain   User?                    @relation("MatchApprover", fields: [approvedByCaptainId], references: [id])
  scoringCaptain      User?                    @relation("MatchScorer", fields: [scoringCaptainId], references: [id])
  teamA               Team                     @relation("MatchTeamA", fields: [teamAId], references: [id])
  teamB               Team                     @relation("MatchTeamB", fields: [teamBId], references: [id])
  tournament          Tournament?              @relation(fields: [tournamentId], references: [id], onUpdate: NoAction)
  winnerTeam          Team?                    @relation("MatchWinner", fields: [winnerTeamId], references: [id])
  playerStats         PlayerStat[]
  scoreUpdates        ScoreUpdate[]
  scoreVerifications  MatchScoreVerification[]
  startApprovals      MatchStartApproval[]

  @@index([tournamentId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([matchDate])
  @@index([status])
  @@index([scoringStatus])
  @@map("matches")
}

model MatchScore {
  id            String   @id @default(uuid())
  matchId       String   @map("match_id")
  battingTeamId String   @map("batting_team_id")
  totalRuns     Int      @default(0) @map("total_runs")
  totalWickets  Int      @default(0) @map("total_wickets")
  totalOvers    Decimal  @default(0.0) @map("total_overs") @db.Decimal(4, 1)
  extrasWide    Int      @default(0) @map("extras_wide")
  extrasNoball  Int      @default(0) @map("extras_noball")
  extrasBye     Int      @default(0) @map("extras_bye")
  extrasLegbye  Int      @default(0) @map("extras_legbye")
  inningsNumber Int      @default(1) @map("innings_number")
  isCompleted   Boolean  @default(false) @map("is_completed")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  battingTeam   Team     @relation(fields: [battingTeamId], references: [id])
  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, battingTeamId, inningsNumber])
  @@index([matchId])
  @@index([battingTeamId])
  @@map("match_scores")
}

model PlayerStat {
  id           String   @id @default(uuid())
  playerId     String   @map("player_id")
  matchId      String   @map("match_id")
  teamId       String   @map("team_id")
  runsScored   Int      @default(0) @map("runs_scored")
  ballsFaced   Int      @default(0) @map("balls_faced")
  fours        Int      @default(0)
  sixes        Int      @default(0)
  wicketsTaken Int      @default(0) @map("wickets_taken")
  oversBowled  Decimal  @default(0.0) @map("overs_bowled") @db.Decimal(4, 1)
  runsConceded Int      @default(0) @map("runs_conceded")
  catches      Int      @default(0)
  stumpings    Int      @default(0)
  runOuts      Int      @default(0) @map("run_outs")
  createdAt    DateTime @default(now()) @map("created_at")
  match        Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player       User     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  team         Team     @relation(fields: [teamId], references: [id])

  @@unique([playerId, matchId])
  @@index([playerId])
  @@index([matchId])
  @@index([teamId])
  @@map("player_stats")
}

model ScoreUpdate {
  id            String   @id @default(uuid())
  matchId       String   @map("match_id")
  updatedBy     String   @map("updated_by")
  updateType    String   @map("update_type")
  runsAdded     Int      @default(0) @map("runs_added")
  isWicket      Boolean  @default(false) @map("is_wicket")
  extraType     String?  @map("extra_type")
  battingTeamId String   @map("batting_team_id")
  currentOver   Decimal  @map("current_over") @db.Decimal(4, 1)
  synced        Boolean  @default(true)
  createdAt     DateTime @default(now()) @map("created_at")
  battingTeam   Team     @relation(fields: [battingTeamId], references: [id])
  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  updater       User     @relation(fields: [updatedBy], references: [id])

  @@index([matchId])
  @@index([synced])
  @@index([createdAt])
  @@map("score_updates")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  link      String?
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

enum UserRole {
  PLAYER
  CAPTAIN
  ADMIN
}

enum PlayerType {
  BATSMAN
  BOWLER
  ALL_ROUNDER
  WICKET_KEEPER
}

enum TeamMemberStatus {
  ACTIVE
  PENDING
  INVITED
  REJECTED
}

enum TournamentStatus {
  UPCOMING
  ONGOING
  COMPLETED
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum MatchType {
  LEAGUE
  KNOCKOUT
  FRIENDLY
}

enum NotificationType {
  JOIN_REQUEST
  INVITATION
  MATCH_SCHEDULED
  SCORE_UPDATE
  TEAM_UPDATE
}

// Feature 5: Score Verification System
model MatchScoreVerification {
  id            String    @id @default(uuid())
  matchId       String    @map("match_id")
  match         Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  submittedBy   String    @map("submitted_by")
  submitter     User      @relation("ScoreSubmitter", fields: [submittedBy], references: [id], onDelete: Cascade)
  verifiedBy    String?   @map("verified_by")
  verifier      User?     @relation("ScoreVerifier", fields: [verifiedBy], references: [id], onDelete: SetNull)
  status        String    @default("PENDING") // PENDING, VERIFIED, DISPUTED, FINAL
  teamAScore    Int       @map("team_a_score")
  teamBScore    Int       @map("team_b_score")
  teamAWickets  Int       @map("team_a_wickets")
  teamBWickets  Int       @map("team_b_wickets")
  disputeReason String?   @map("dispute_reason")
  submittedAt   DateTime  @default(now()) @map("submitted_at")
  verifiedAt    DateTime? @map("verified_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([matchId])
  @@index([submittedBy])
  @@index([status])
  @@map("match_score_verifications")
}

// Feature 6: Match Start Approval System
model MatchStartApproval {
  id           String    @id @default(uuid())
  matchId      String    @map("match_id")
  match        Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  requestedBy  String    @map("requested_by")
  requester    User      @relation("ApprovalRequester", fields: [requestedBy], references: [id], onDelete: Cascade)
  approvedBy   String?   @map("approved_by")
  approver     User?     @relation("ApprovalApprover", fields: [approvedBy], references: [id], onDelete: SetNull)
  status       String    @default("PENDING") // PENDING, APPROVED, REJECTED
  requestedAt   DateTime  @default(now()) @map("requested_at")
  respondedAt  DateTime? @map("responded_at")

  @@index([matchId])
  @@index([requestedBy])
  @@index([status])
  @@map("match_start_approvals")
}
