generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                  String                   @id @default(uuid())
  email               String                   @unique
  password            String
  fullName            String                   @map("full_name")
  role                UserRole                 @default(PLAYER)
  playerType          PlayerType?              @map("player_type")
  phone               String?
  profilePictureUrl   String?                  @map("profile_picture_url")
  city                String?
  locationLatitude    Decimal?                 @map("location_latitude") @db.Decimal(10, 8)
  locationLongitude   Decimal?                 @map("location_longitude") @db.Decimal(11, 8)
  createdAt           DateTime                 @default(now()) @map("created_at")
  updatedAt           DateTime                 @updatedAt @map("updated_at")
  isBlocked           Boolean                  @default(false) @map("is_blocked")
  isSuspended         Boolean                  @default(false) @map("is_suspended")
  suspendReason       String?                  @map("suspend_reason")
  suspendedAt         DateTime?                @map("suspended_at")
  matchesAsApprover   Match[]                  @relation("MatchApprover")
  matchesAsScorer     Match[]                  @relation("MatchScorer")
  notifications       Notification[]
  passwordResetTokens PasswordResetToken[]
  playerStats         PlayerStat[]
  refreshTokens       RefreshToken[]
  scoreUpdates        ScoreUpdate[]
  teamMemberships     TeamMember[]
  captainedTeams      Team[]                   @relation("TeamCaptain")
  createdTournaments  Tournament[]
  scoresSubmitted     MatchScoreVerification[] @relation("ScoreSubmitter")
  scoresVerified      MatchScoreVerification[] @relation("ScoreVerifier")
  approvalRequests    MatchStartApproval[]     @relation("ApprovalRequester")
  approvalsGiven      MatchStartApproval[]     @relation("ApprovalApprover")
  // New relations for enhanced scoring system
  ballsEntered        Ball[]                   @relation("BallEntered")
  batsmanOnStrike     Ball[]                   @relation("BatsmanOnStrike")
  batsmanNonStrike    Ball[]                   @relation("BatsmanNonStrike")
  bowled              Ball[]                   @relation("Bowler")
  newApprovalRequests ApprovalRequest[]        @relation("NewApprovalRequester")
  newApprovalsGiven   ApprovalRequest[]        @relation("NewApprovalApprover")
  captainSettings     CaptainSettings?
  auditLogs           AuditLog[]

  @@index([email])
  @@index([role])
  @@index([createdAt])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@index([used])
  @@map("password_reset_tokens")
}

model Team {
  id                String        @id @default(uuid())
  teamName          String        @unique @map("team_name")
  captainId         String        @map("captain_id")
  logoUrl           String?       @map("logo_url")
  description       String?
  city              String?
  locationLatitude  Decimal?      @map("location_latitude") @db.Decimal(10, 8)
  locationLongitude Decimal?      @map("location_longitude") @db.Decimal(11, 8)
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  matchScores       MatchScore[]
  matchesAsTeamA    Match[]       @relation("MatchTeamA")
  matchesAsTeamB    Match[]       @relation("MatchTeamB")
  matchesAsWinner   Match[]       @relation("MatchWinner")
  playerStats       PlayerStat[]
  scoreUpdates      ScoreUpdate[]
  members           TeamMember[]
  captain           User          @relation("TeamCaptain", fields: [captainId], references: [id], onDelete: Cascade)

  @@index([captainId])
  @@index([teamName])
  @@index([createdAt])
  @@map("teams")
}

model TeamMember {
  id          String           @id @default(uuid())
  teamId      String           @map("team_id")
  playerId    String           @map("player_id")
  status      TeamMemberStatus @default(PENDING)
  isTemporary Boolean          @default(false) @map("is_temporary")
  roleInTeam  String?          @map("role_in_team")
  joinedAt    DateTime?        @map("joined_at")
  createdAt   DateTime         @default(now()) @map("created_at")
  player      User             @relation(fields: [playerId], references: [id], onDelete: Cascade)
  team        Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, playerId])
  @@index([teamId])
  @@index([playerId])
  @@index([status])
  @@map("team_members")
}

model Tournament {
  id             String           @id @default(uuid())
  tournamentName String           @map("tournament_name")
  startDate      DateTime         @map("start_date") @db.Date
  endDate        DateTime         @map("end_date") @db.Date
  status         TournamentStatus @default(UPCOMING)
  createdBy      String           @map("created_by")
  description    String?
  location       String?
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")
  matches        Match[]
  creator        User             @relation(fields: [createdBy], references: [id])

  @@index([status])
  @@index([startDate, endDate])
  @@index([createdBy])
  @@map("tournaments")
}

model Match {
  id                      String                   @id @default(uuid())
  tournamentId            String?                  @map("tournament_id")
  teamAId                 String                   @map("team_a_id")
  teamBId                 String                   @map("team_b_id")
  venue                   String
  matchDate               DateTime                 @map("match_date")
  matchType               MatchType?               @map("match_type")
  status                  MatchStatus              @default(SCHEDULED)
  scoringCaptainId        String?                  @map("scoring_captain_id")
  approvedByCaptainId     String?                  @map("approved_by_captain_id")
  winnerTeamId            String?                  @map("winner_team_id")
  createdAt               DateTime                 @default(now()) @map("created_at")
  updatedAt               DateTime                 @updatedAt @map("updated_at")
  // Scoring fields (Feature 4)
  scoringStatus           String?                  @default("NOT_STARTED") @map("scoring_status")
  currentInning           Int?                     @default(1) @map("current_inning")
  teamAScore              Int?                     @default(0) @map("team_a_score")
  teamAWickets            Int?                     @default(0) @map("team_a_wickets")
  teamAOvers              Decimal?                 @default(0) @map("team_a_overs") @db.Decimal(4, 1)
  teamBScore              Int?                     @default(0) @map("team_b_score")
  teamBWickets            Int?                     @default(0) @map("team_b_wickets")
  teamBOvers              Decimal?                 @default(0) @map("team_b_overs") @db.Decimal(4, 1)
  scoringStartedAt        DateTime?                @map("scoring_started_at")
  scoringCompletedAt      DateTime?                @map("scoring_completed_at")
  scoringStartedBy        String?                  @map("scoring_started_by")
  // New innings tracking fields
  firstInningsComplete    Boolean                  @default(false) @map("first_innings_complete")
  secondInningsComplete   Boolean                  @default(false) @map("second_innings_complete")
  // Approval tracking fields
  scoringStartApprovedBy  String?                  @map("scoring_start_approved_by")
  scoringStartApprovedAt  DateTime?                @map("scoring_start_approved_at")
  secondInningsApprovedBy String?                  @map("second_innings_approved_by")
  secondInningsApprovedAt DateTime?                @map("second_innings_approved_at")
  finalScoreApprovedBy    Json?                    @default("[]") @map("final_score_approved_by") // Array of captain IDs stored as JSON
  finalScoreApprovedAt    DateTime?                @map("final_score_approved_at")
  scores                  MatchScore[]
  balls                   Ball[]
  approvalRequests        ApprovalRequest[]
  auditLogs               AuditLog[]
  approvedByCaptain       User?                    @relation("MatchApprover", fields: [approvedByCaptainId], references: [id])
  scoringCaptain          User?                    @relation("MatchScorer", fields: [scoringCaptainId], references: [id])
  teamA                   Team                     @relation("MatchTeamA", fields: [teamAId], references: [id])
  teamB                   Team                     @relation("MatchTeamB", fields: [teamBId], references: [id])
  tournament              Tournament?              @relation(fields: [tournamentId], references: [id], onUpdate: NoAction)
  winnerTeam              Team?                    @relation("MatchWinner", fields: [winnerTeamId], references: [id])
  playerStats             PlayerStat[]
  scoreUpdates            ScoreUpdate[]
  scoreVerifications      MatchScoreVerification[]
  startApprovals          MatchStartApproval[]

  @@index([tournamentId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([matchDate])
  @@index([status])
  @@index([scoringStatus])
  @@map("matches")
}

model MatchScore {
  id            String   @id @default(uuid())
  matchId       String   @map("match_id")
  battingTeamId String   @map("batting_team_id")
  totalRuns     Int      @default(0) @map("total_runs")
  totalWickets  Int      @default(0) @map("total_wickets")
  totalOvers    Decimal  @default(0.0) @map("total_overs") @db.Decimal(4, 1)
  extrasWide    Int      @default(0) @map("extras_wide")
  extrasNoball  Int      @default(0) @map("extras_noball")
  extrasBye     Int      @default(0) @map("extras_bye")
  extrasLegbye  Int      @default(0) @map("extras_legbye")
  inningsNumber Int      @default(1) @map("innings_number")
  isCompleted   Boolean  @default(false) @map("is_completed")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  battingTeam   Team     @relation(fields: [battingTeamId], references: [id])
  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, battingTeamId, inningsNumber])
  @@index([matchId])
  @@index([battingTeamId])
  @@map("match_scores")
}

model PlayerStat {
  id           String   @id @default(uuid())
  playerId     String   @map("player_id")
  matchId      String   @map("match_id")
  teamId       String   @map("team_id")
  runsScored   Int      @default(0) @map("runs_scored")
  ballsFaced   Int      @default(0) @map("balls_faced")
  fours        Int      @default(0)
  sixes        Int      @default(0)
  wicketsTaken Int      @default(0) @map("wickets_taken")
  oversBowled  Decimal  @default(0.0) @map("overs_bowled") @db.Decimal(4, 1)
  runsConceded Int      @default(0) @map("runs_conceded")
  catches      Int      @default(0)
  stumpings    Int      @default(0)
  runOuts      Int      @default(0) @map("run_outs")
  createdAt    DateTime @default(now()) @map("created_at")
  match        Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player       User     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  team         Team     @relation(fields: [teamId], references: [id])

  @@unique([playerId, matchId])
  @@index([playerId])
  @@index([matchId])
  @@index([teamId])
  @@map("player_stats")
}

model ScoreUpdate {
  id            String   @id @default(uuid())
  matchId       String   @map("match_id")
  updatedBy     String   @map("updated_by")
  updateType    String   @map("update_type")
  runsAdded     Int      @default(0) @map("runs_added")
  isWicket      Boolean  @default(false) @map("is_wicket")
  extraType     String?  @map("extra_type")
  battingTeamId String   @map("batting_team_id")
  currentOver   Decimal  @map("current_over") @db.Decimal(4, 1)
  synced        Boolean  @default(true)
  createdAt     DateTime @default(now()) @map("created_at")
  battingTeam   Team     @relation(fields: [battingTeamId], references: [id])
  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  updater       User     @relation(fields: [updatedBy], references: [id])

  @@index([matchId])
  @@index([synced])
  @@index([createdAt])
  @@map("score_updates")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  link      String?
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

enum UserRole {
  PLAYER
  CAPTAIN
  ADMIN
}

enum PlayerType {
  BATSMAN
  BOWLER
  ALL_ROUNDER
  WICKET_KEEPER
}

enum TeamMemberStatus {
  ACTIVE
  PENDING
  INVITED
  REJECTED
}

enum TournamentStatus {
  UPCOMING
  ONGOING
  COMPLETED
}

enum MatchStatus {
  SCHEDULED
  SCORING_PENDING
  FIRST_INNINGS
  SECOND_INNINGS_PENDING
  SECOND_INNINGS
  FINAL_PENDING
  COMPLETED
  CANCELLED
  DISPUTED
  LIVE // Keep for backward compatibility, will be deprecated
}

enum MatchType {
  LEAGUE
  KNOCKOUT
  FRIENDLY
}

enum NotificationType {
  JOIN_REQUEST
  INVITATION
  MATCH_SCHEDULED
  SCORE_UPDATE
  TEAM_UPDATE
  APPROVAL_REQUESTED
  APPROVAL_GRANTED
  APPROVAL_AUTO_APPROVED
  MATCH_STATUS_CHANGED
}

// Feature 5: Score Verification System
model MatchScoreVerification {
  id            String    @id @default(uuid())
  matchId       String    @map("match_id")
  match         Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  submittedBy   String    @map("submitted_by")
  submitter     User      @relation("ScoreSubmitter", fields: [submittedBy], references: [id], onDelete: Cascade)
  verifiedBy    String?   @map("verified_by")
  verifier      User?     @relation("ScoreVerifier", fields: [verifiedBy], references: [id], onDelete: SetNull)
  status        String    @default("PENDING") // PENDING, VERIFIED, DISPUTED, FINAL
  teamAScore    Int       @map("team_a_score")
  teamBScore    Int       @map("team_b_score")
  teamAWickets  Int       @map("team_a_wickets")
  teamBWickets  Int       @map("team_b_wickets")
  disputeReason String?   @map("dispute_reason")
  submittedAt   DateTime  @default(now()) @map("submitted_at")
  verifiedAt    DateTime? @map("verified_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([matchId])
  @@index([submittedBy])
  @@index([status])
  @@map("match_score_verifications")
}

// Feature 6: Match Start Approval System (Legacy - kept for backward compatibility)
model MatchStartApproval {
  id          String    @id @default(uuid())
  matchId     String    @map("match_id")
  match       Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  requestedBy String    @map("requested_by")
  requester   User      @relation("ApprovalRequester", fields: [requestedBy], references: [id], onDelete: Cascade)
  approvedBy  String?   @map("approved_by")
  approver    User?     @relation("ApprovalApprover", fields: [approvedBy], references: [id], onDelete: SetNull)
  status      String    @default("PENDING") // PENDING, APPROVED, REJECTED
  requestedAt DateTime  @default(now()) @map("requested_at")
  respondedAt DateTime? @map("responded_at")

  @@index([matchId])
  @@index([requestedBy])
  @@index([status])
  @@map("match_start_approvals")
}

// Enhanced Approval System - Unified for all approval points
model ApprovalRequest {
  id                 String         @id @default(uuid())
  matchId            String         @map("match_id")
  match              Match          @relation(fields: [matchId], references: [id], onDelete: Cascade)
  type               ApprovalType
  requestedBy        String         @map("requested_by")
  requester          User           @relation("NewApprovalRequester", fields: [requestedBy], references: [id], onDelete: Cascade)
  approvedBy         String?        @map("approved_by")
  approver           User?          @relation("NewApprovalApprover", fields: [approvedBy], references: [id], onDelete: SetNull)
  status             ApprovalStatus @default(PENDING)
  requestedAt        DateTime       @default(now()) @map("requested_at")
  approvedAt         DateTime?      @map("approved_at")
  // Auto-approval fields
  autoApproveAt      DateTime       @map("auto_approve_at")
  autoApproveEnabled Boolean        @default(true) @map("auto_approve_enabled")
  wasAutoApproved    Boolean        @default(false) @map("was_auto_approved")

  @@index([matchId])
  @@index([requestedBy])
  @@index([status])
  @@index([autoApproveAt])
  @@index([type, status])
  @@map("approval_requests")
}

enum ApprovalType {
  START_SCORING
  START_SECOND_INNINGS
  FINAL_SCORE
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  AUTO_APPROVED
  EXPIRED
  CANCELLED
}

// Ball-by-ball scoring model
model Ball {
  id               String      @id @default(uuid())
  matchId          String      @map("match_id")
  match            Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  innings          Int // 1 or 2
  overNumber       Int         @map("over_number")
  ballNumber       Int         @map("ball_number") // 1-6 (7+ for extras)
  batsmanOnStrike  String      @map("batsman_on_strike")
  striker          User        @relation("BatsmanOnStrike", fields: [batsmanOnStrike], references: [id])
  batsmanNonStrike String      @map("batsman_non_strike")
  nonStriker       User        @relation("BatsmanNonStrike", fields: [batsmanNonStrike], references: [id])
  bowler           String
  bowlerUser       User        @relation("Bowler", fields: [bowler], references: [id])
  runs             Int         @default(0)
  isWicket         Boolean     @default(false) @map("is_wicket")
  wicketType       WicketType? @map("wicket_type")
  dismissedPlayer  String?     @map("dismissed_player")
  fielder          String? // For caught/run out
  isWide           Boolean     @default(false) @map("is_wide")
  isNoBall         Boolean     @default(false) @map("is_no_ball")
  isBye            Boolean     @default(false) @map("is_bye")
  isLegBye         Boolean     @default(false) @map("is_leg_bye")
  timestamp        DateTime    @default(now())
  enteredBy        String      @map("entered_by")
  enteredByUser    User        @relation("BallEntered", fields: [enteredBy], references: [id])

  @@index([matchId, innings, overNumber])
  @@index([matchId])
  @@index([batsmanOnStrike])
  @@index([bowler])
  @@index([timestamp])
  @@map("balls")
}

enum WicketType {
  BOWLED
  CAUGHT
  LBW
  RUN_OUT
  STUMPED
  HIT_WICKET
  RETIRED_HURT
}

// Captain settings for timeout preferences
model CaptainSettings {
  id                  String   @id @default(uuid())
  userId              String   @unique @map("user_id")
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  autoApproveEnabled  Boolean  @default(true) @map("auto_approve_enabled")
  timeoutMinutes      Int      @default(5) @map("timeout_minutes")
  notifyOnAutoApprove Boolean  @default(true) @map("notify_on_auto_approve")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  @@map("captain_settings")
}

// Comprehensive audit logging
model AuditLog {
  id              String        @id @default(uuid())
  matchId         String?       @map("match_id")
  match           Match?        @relation(fields: [matchId], references: [id], onDelete: Cascade)
  action          AuditAction
  performedBy     String        @map("performed_by")
  user            User          @relation(fields: [performedBy], references: [id])
  performedAt     DateTime      @default(now()) @map("performed_at")
  // State tracking
  previousState   Json?         @map("previous_state")
  newState        Json?         @map("new_state")
  // Context
  approvalType    ApprovalType? @map("approval_type")
  wasAutoApproved Boolean?      @map("was_auto_approved")
  ballNumber      Int?          @map("ball_number")
  overNumber      Int?          @map("over_number")
  // Meta
  ipAddress       String?       @map("ip_address")
  userAgent       String?       @map("user_agent")

  @@index([matchId, performedAt])
  @@index([action, performedAt])
  @@index([performedBy])
  @@map("audit_logs")
}

enum AuditAction {
  MATCH_CREATED
  STATUS_CHANGED
  APPROVAL_REQUESTED
  APPROVAL_GRANTED
  APPROVAL_REJECTED
  APPROVAL_AUTO_APPROVED
  BALL_ENTERED
  BALL_DELETED
  BALL_MODIFIED
  INNINGS_ENDED
  STATS_CALCULATED
  STATS_UPDATED
  TIMEOUT_ENABLED
  TIMEOUT_DISABLED
}
